diff --git a/mimicgen/__init__.py b/mimicgen/__init__.py
index 0affb00..3bad7a4 100644
--- a/mimicgen/__init__.py
+++ b/mimicgen/__init__.py
@@ -2,6 +2,7 @@
 #
 # Licensed under the NVIDIA Source Code License [see LICENSE for details].
 
+
 __version__ = "1.0.1"
 
 # try to import all environment interfaces here
@@ -24,12 +25,12 @@ except ImportError as e:
     print("WARNING: robosuite environments not imported...")
     print("Got error: {}".format(e))
 
-try:
-    from mimicgen.envs.robosuite.hammer_cleanup import *
-    from mimicgen.envs.robosuite.kitchen import *
-except ImportError as e:
-    print("WARNING: robosuite task zoo environments not imported, possibly because robosuite_task_zoo is not installed...")
-    print("Got error: {}".format(e))
+# try:
+#     from mimicgen.envs.robosuite.hammer_cleanup import *
+#     from mimicgen.envs.robosuite.kitchen import *
+# except ImportError as e:
+#     print("WARNING: robosuite task zoo environments not imported, possibly because robosuite_task_zoo is not installed...")
+#     print("Got error: {}".format(e))
 
 # stores released dataset links and rollout horizons in global dictionary.
 # Structure is given below for each type of dataset:
@@ -54,7 +55,7 @@ def register_dataset_link(dataset_type, task, link, horizon):
     rollout horizon that should be used during training.
 
     Args:
-        dataset_type (str): identifies the type of dataset (e.g. source human data, 
+        dataset_type (str): identifies the type of dataset (e.g. source human data,
             core experiment data, object transfer data)
         task (str): name of task for this dataset
         link (str): download link for the dataset
@@ -184,7 +185,8 @@ def register_all_links():
         ("square_d1", 500, "large_interpolation/square_d1.hdf5"),
         ("stack_d1", 500, "large_interpolation/stack_d1.hdf5"),
         ("threading_d1", 500, "large_interpolation/threading_d1.hdf5"),
-        ("three_piece_assembly_d1", 700, "large_interpolation/three_piece_assembly_d1.hdf5"),
+        ("three_piece_assembly_d1", 700,
+         "large_interpolation/three_piece_assembly_d1.hdf5"),
     ]
     for task, horizon, link in dataset_infos:
         register_dataset_link(
@@ -194,4 +196,5 @@ def register_all_links():
             link=link,
         )
 
+
 register_all_links()
diff --git a/mimicgen/envs/robosuite/coffee.py b/mimicgen/envs/robosuite/coffee.py
index f7a72a7..2c40527 100644
--- a/mimicgen/envs/robosuite/coffee.py
+++ b/mimicgen/envs/robosuite/coffee.py
@@ -20,6 +20,10 @@ from robosuite.utils.observables import Observable, sensor
 import mimicgen
 from mimicgen.models.robosuite.objects import BlenderObject, CoffeeMachinePodObject, CoffeeMachineObject, LongDrawerObject, CupObject
 from mimicgen.envs.robosuite.single_arm_env_mg import SingleArmEnv_MG
+from robosuite.utils.camera_utils import get_camera_extrinsic_matrix
+
+
+from mirrorduo.utils.core_utils import mirror_object_placements, mirror_object
 
 
 class Coffee(SingleArmEnv_MG):
@@ -169,6 +173,7 @@ class Coffee(SingleArmEnv_MG):
         camera_segmentations=None,  # {None, instance, class, element}
         renderer="mujoco",
         renderer_config=None,
+        mirror_scene=False
     ):
         # settings for table top
         self.table_full_size = table_full_size
@@ -181,6 +186,7 @@ class Coffee(SingleArmEnv_MG):
 
         # whether to use ground-truth object states
         self.use_object_obs = use_object_obs
+        self.mirror_scene = mirror_scene
 
         super().__init__(
             robots=robots,
@@ -209,6 +215,17 @@ class Coffee(SingleArmEnv_MG):
             renderer_config=renderer_config,
         )
 
+    def mirror_objects(self):
+        # Override to not mirror the nut
+        for obj in [self.coffee_machine, self.coffee_pod]:
+            res = self.sim.data.get_joint_qpos(obj.joints[0])
+            pos, quat = res[:3], res[3:]
+            X_C = get_camera_extrinsic_matrix(self.sim, "agentview")
+            pos, quat = mirror_object(X_C, pos, quat, rot_180=False)
+            res = np.concatenate((pos, quat))
+            self.sim.data.set_joint_qpos(obj.joints[0], res)
+        self.sim.forward()
+
     def reward(self, action=None):
         """
         Reward function for the task.
@@ -250,14 +267,7 @@ class Coffee(SingleArmEnv_MG):
         self.robots[0].robot_model.set_base_xpos(xpos)
 
         # load model for table top workspace
-        mujoco_arena = TableArena(
-            table_full_size=self.table_full_size,
-            table_friction=self.table_friction,
-            table_offset=self.table_offset,
-        )
-
-        # Arena always gets set to zero origin
-        mujoco_arena.set_origin([0, 0, 0])
+        mujoco_arena = self._load_arena()
 
         # Add camera with full tabletop perspective
         self._add_agentview_full_camera(mujoco_arena)
@@ -277,6 +287,16 @@ class Coffee(SingleArmEnv_MG):
             mujoco_objects=objects,
         )
 
+    def _load_arena(self):
+        mujoco_arena = TableArena(
+            table_full_size=self.table_full_size,
+            table_friction=self.table_friction,
+            table_offset=self.table_offset,
+        )
+        # Arena always gets set to zero origin
+        mujoco_arena.set_origin([0, 0, 0])
+        return mujoco_arena
+
     def _get_initial_placement_bounds(self):
         """
         Internal function to get bounds for randomization of initial placements of objects (e.g.
@@ -378,8 +398,8 @@ class Coffee(SingleArmEnv_MG):
             object_placements = self.placement_initializer.sample()
 
             # Loop through all objects and reset their positions
-            for obj_pos, obj_quat, obj in object_placements.values():
-                self.sim.data.set_joint_qpos(obj.joints[0], np.concatenate([np.array(obj_pos), np.array(obj_quat)]))
+            mirror_object_placements(
+                self, object_placements, self.mirror_scene)
 
         # Always reset the hinge joint position
         self.sim.data.qpos[self.hinge_qpos_addr] = 2. * np.pi / 3.
@@ -767,12 +787,23 @@ class Coffee(SingleArmEnv_MG):
         if vis_settings["grippers"]:
             self._visualize_gripper_to_target(gripper=self.robots[0].gripper, target=self.coffee_machine)
 
+    def get_agentview_extrinsics(self):
+        return get_camera_extrinsic_matrix(self.sim, "agentview")
+
 
 class Coffee_D0(Coffee):
     """Rename base class for convenience."""
     pass
 
 
+class Coffee_D0_Mirror(Coffee_D0):
+    def __init__(self, **kwargs):
+        """
+        Initialize the Coffee_D0_Mirror environment.
+        """
+        Coffee_D0.__init__(self, mirror_scene=True, **kwargs)
+
+
 class Coffee_D1(Coffee_D0):
     """
     Wider initialization for pod and coffee machine.
@@ -841,6 +872,33 @@ class Coffee_D2(Coffee_D1):
         )
 
 
+class Coffee_D2_Mirror(Coffee_D2):
+    def __init__(self, **kwargs):
+        """
+        Initialize the Coffee_D0_Mirror environment.
+        """
+        Coffee_D2.__init__(self, mirror_scene=True, **kwargs)
+
+
+class Coffee_D2_Agentview_Far(Coffee_D2):
+    def _load_arena(self):
+        mujoco_arena = super()._load_arena()
+        mujoco_arena.set_camera(
+            camera_name="agentview",
+            pos=string_to_array("1.2 0.0 1.85"),
+            quat=string_to_array("0.6123724 0.3535534 0.3535534 0.6123724"),
+        )
+        return mujoco_arena
+
+
+class Coffee_D2_Agentview_Far_Mirror(Coffee_D2_Agentview_Far):
+    def __init__(self, **kwargs):
+        """
+        Initialize the Coffee_D0_Mirror environment.
+        """
+        Coffee_D2_Agentview_Far.__init__(self, mirror_scene=True, **kwargs)
+
+
 class CoffeePreparation(Coffee):
     """
     Harder coffee task where the task starts with materials in drawer and coffee machine closed. The robot
@@ -971,7 +1029,7 @@ class CoffeePreparation(Coffee):
         )
         # HACK: merge in mug afterwards because its number of geoms may change
         #       and this may break the generate_id_mappings function in task.py
-        self.model.merge_objects([self.mug]) # add cleanup object to model 
+        self.model.merge_objects([self.mug])  # add cleanup object to model
 
     def _get_initial_placement_bounds(self):
         """
@@ -1122,7 +1180,7 @@ class CoffeePreparation(Coffee):
                     body_id = self.sim.model.body_name2id(obj.root_body)
                     obj_pos_to_set = np.array(obj_pos)
                     # obj_pos_to_set[2] = 0.905 # hardcode z-value to correspond to parent class
-                    obj_pos_to_set[2] = 0.805 # hardcode z-value to make sure it lies on table surface
+                    obj_pos_to_set[2] = 0.805  # hardcode z-value to make sure it lies on table surface
                     self.sim.model.body_pos[body_id] = obj_pos_to_set
                     self.sim.model.body_quat[body_id] = obj_quat
                 else:
diff --git a/mimicgen/envs/robosuite/nut_assembly.py b/mimicgen/envs/robosuite/nut_assembly.py
index 3f3c359..2f81122 100644
--- a/mimicgen/envs/robosuite/nut_assembly.py
+++ b/mimicgen/envs/robosuite/nut_assembly.py
@@ -18,11 +18,20 @@ from robosuite.utils import RandomizationError
 
 from mimicgen.envs.robosuite.single_arm_env_mg import SingleArmEnv_MG
 
+from mirrorduo.utils.core_utils import (
+    camera_pose_from_xml,
+    mirror_object,
+    mirror_object_placements,
+)
+
+from robosuite.utils.camera_utils import get_camera_extrinsic_matrix
+
 
 class NutAssembly_D0(NutAssembly, SingleArmEnv_MG):
     """
     Augment robosuite nut assembly task for mimicgen.
     """
+
     def __init__(self, **kwargs):
         NutAssembly.__init__(self, **kwargs)
 
@@ -45,14 +54,14 @@ class NutAssembly_D0(NutAssembly, SingleArmEnv_MG):
             square_nut=dict(
                 x=(-0.115, -0.11),
                 y=(0.11, 0.225),
-                z_rot=(0., 2. * np.pi),
+                z_rot=(0.0, 2.0 * np.pi),
                 # NOTE: hardcoded @self.table_offset since this might be called in init function
                 reference=np.array((0, 0, 0.82)),
             ),
             round_nut=dict(
                 x=(-0.115, -0.11),
                 y=(-0.225, -0.11),
-                z_rot=(0., 2. * np.pi),
+                z_rot=(0.0, 2.0 * np.pi),
                 # NOTE: hardcoded @self.table_offset since this might be called in init function
                 reference=np.array((0, 0, 0.82)),
             ),
@@ -63,8 +72,11 @@ class Square_D0(NutAssemblySquare, SingleArmEnv_MG):
     """
     Augment robosuite nut assembly square task for mimicgen.
     """
-    def __init__(self, **kwargs):
-        assert "placement_initializer" not in kwargs, "this class defines its own placement initializer"
+
+    def __init__(self, mirror_scene=False, **kwargs):
+        assert (
+            "placement_initializer" not in kwargs
+        ), "this class defines its own placement initializer"
 
         # make placement initializer here
         nut_names = ("SquareNut", "RoundNut")
@@ -79,14 +91,16 @@ class Square_D0(NutAssemblySquare, SingleArmEnv_MG):
         nut_references = (bounds["nut"]["reference"], bounds["nut"]["reference"])
 
         placement_initializer = SequentialCompositeSampler(name="ObjectSampler")
-        for nut_name, x_range, y_range, z_range, ref in zip(nut_names, nut_x_ranges, nut_y_ranges, nut_z_ranges, nut_references):
+        for nut_name, x_range, y_range, z_range, ref in zip(
+            nut_names, nut_x_ranges, nut_y_ranges, nut_z_ranges, nut_references
+        ):
             placement_initializer.append_sampler(
                 sampler=UniformRandomSampler(
                     name=f"{nut_name}Sampler",
                     x_range=x_range,
                     y_range=y_range,
                     rotation=z_range,
-                    rotation_axis='z',
+                    rotation_axis="z",
                     ensure_object_boundary_in_range=False,
                     ensure_valid_placement=True,
                     reference_pos=ref,
@@ -94,6 +108,8 @@ class Square_D0(NutAssemblySquare, SingleArmEnv_MG):
                 )
             )
 
+        self.mirror_scene = mirror_scene
+
         NutAssemblySquare.__init__(self, placement_initializer=placement_initializer, **kwargs)
 
     def edit_model_xml(self, xml_str):
@@ -115,31 +131,265 @@ class Square_D0(NutAssemblySquare, SingleArmEnv_MG):
             nut=dict(
                 x=(-0.115, -0.11),
                 y=(0.11, 0.225),
-                z_rot=(0., 2. * np.pi),
+                z_rot=(0.0, 2.0 * np.pi),
                 # NOTE: hardcoded @self.table_offset since this might be called in init function
                 reference=np.array((0, 0, 0.82)),
             ),
         )
 
+    # [mirrorduo] override to not mirror the nut
+    def _reset_internal(self):
+        """
+        Resets simulation internal configurations.
+        """
+        super()._reset_internal()
+
+        # Reset all object positions using initializer sampler if we're not directly loading from an xml
+
+        if not self.deterministic_reset:
+
+            # Sample from the placement initializer for all objects
+            object_placements = self.placement_initializer.sample()
+
+            # Loop through all objects and reset their positions
+            mirror_object_placements(self, object_placements, self.mirror_scene)
+
+        # Move objects out of the scene depending on the mode
+        nut_names = {nut.name for nut in self.nuts}
+        if self.single_object_mode == 1:
+            self.obj_to_use = random.choice(list(nut_names))
+            for nut_type, i in self.nut_to_id.items():
+                if nut_type.lower() in self.obj_to_use.lower():
+                    self.nut_id = i
+                    break
+        elif self.single_object_mode == 2:
+            self.obj_to_use = self.nuts[self.nut_id].name
+        if self.single_object_mode in {1, 2}:
+            nut_names.remove(self.obj_to_use)
+            self.clear_objects(list(nut_names))
+
+        # Make sure to update sensors' active and enabled states
+        if self.single_object_mode != 0:
+            for i, sensor_names in self.nut_id_to_sensors.items():
+                for name in sensor_names:
+                    # Set all of these sensors to be enabled and active if this is the active nut, else False
+                    self._observables[name].set_enabled(i == self.nut_id)
+                    self._observables[name].set_active(i == self.nut_id)
+
+    def _load_model(self):
+        """
+        Override to modify xml of pegs. This is necessary because the pegs don't have free
+        joints, so we must modify the xml directly before loading the model.
+        """
+
+        # skip superclass implementation
+        SingleArmEnv._load_model(self)
+
+        # Adjust base pose accordingly
+        xpos = self.robots[0].robot_model.base_xpos_offset["table"](self.table_full_size[0])
+        self.robots[0].robot_model.set_base_xpos(xpos)
+
+        # load model for table top workspace
+        mujoco_arena = self._load_arena()
+
+        # define nuts
+        self.nuts = []
+        nut_names = ("SquareNut", "RoundNut")
+
+        # super class should already give us placement initializer in init
+        assert self.placement_initializer is not None
+
+        # Reset sampler before adding any new samplers / objects
+        self.placement_initializer.reset()
+
+        for i, (nut_cls, nut_name) in enumerate(
+            zip(
+                (SquareNutObject, RoundNutObject),
+                nut_names,
+            )
+        ):
+            nut = nut_cls(name=nut_name)
+            self.nuts.append(nut)
+            # Add this nut to the placement initializer
+            if isinstance(self.placement_initializer, SequentialCompositeSampler):
+                # assumes we have two samplers so we add nuts to them
+                self.placement_initializer.add_objects_to_sampler(
+                    sampler_name=f"{nut_name}Sampler", mujoco_objects=nut
+                )
+            else:
+                # This is assumed to be a flat sampler, so we just add all nuts to this sampler
+                self.placement_initializer.add_objects(nut)
+
+        # get xml element corresponding to both pegs
+        peg1_xml = mujoco_arena.worldbody.find("./body[@name='peg1']")
+        peg2_xml = mujoco_arena.worldbody.find("./body[@name='peg2']")
+        cam_pos, cam_quat = mujoco_arena.get_camera("agentview")
+
+        # apply randomization
+        peg1_xml_pos = string_to_array(peg1_xml.get("pos"))
+        peg1_xml_quat = None
+
+        peg2_xml_pos = string_to_array(peg2_xml.get("pos"))
+        peg2_xml_quat = None
+
+        X_C = camera_pose_from_xml(cam_pos, cam_quat)
+
+        if self.mirror_scene:
+            # HACK: for offcenter camera, we want to mirror across y=0 plane, used in offcenter camera
+            # X_C[1, 3] = 0  
+            peg1_xml_pos, peg1_xml_quat = mirror_object(
+                X_C,
+                peg1_xml_pos,
+                peg1_xml_quat,
+            )
+
+            peg2_xml_pos, peg2_xml_quat = mirror_object(
+                X_C,
+                peg2_xml_pos,
+                peg2_xml_quat,
+            )
+
+        # set modified entry in xml
+        peg1_xml.set("pos", array_to_string(peg1_xml_pos))
+        peg2_xml.set("pos", array_to_string(peg2_xml_pos))
+
+        # task includes arena, robot, and objects of interest
+        self.model = ManipulationTask(
+            mujoco_arena=mujoco_arena,
+            mujoco_robots=[robot.robot_model for robot in self.robots],
+            mujoco_objects=self.nuts,
+        )
+
+    def _load_arena(self):
+        """
+        Allow subclasses to easily override arena settings.
+        """
+
+        # load model for table top workspace
+        mujoco_arena = PegsArena(
+            table_full_size=self.table_full_size,
+            table_friction=self.table_friction,
+            table_offset=self.table_offset,
+        )
+
+        # Arena always gets set to zero origin
+        mujoco_arena.set_origin([0, 0, 0])
+
+        return mujoco_arena
+
+    def get_agentview_extrinsics(self):
+        return get_camera_extrinsic_matrix(self.sim, "agentview")
+
+
+class Square_D0_Mirror(Square_D0):
+    def __init__(self, **kwargs):
+        Square_D0.__init__(self, mirror_scene=True, **kwargs)
+
+    def mirror_objects(self):
+        # Override to not mirror the nut
+        for nut_ in self.nuts:
+            res = self.sim.data.get_joint_qpos(nut_.joints[0])
+            pos, quat = res[:3], res[3:]
+            X_C = self.get_agentview_extrinsics()
+            pos, quat = mirror_object(X_C, pos, quat, rot_180=True)
+            res = np.concatenate((pos, quat))
+            self.sim.data.set_joint_qpos(nut_.joints[0], res)
+        self.sim.forward()
+
+
+class Square_D0_Agentview_Far(Square_D0):
+
+    def _load_arena(self):
+        mujoco_arena = super()._load_arena()
+        mujoco_arena.set_camera(
+            camera_name="agentview",
+            pos=string_to_array("1.2 0.0 1.85"),
+            quat=string_to_array("0.6123724 0.3535534 0.3535534 0.6123724"),
+        )
+        return mujoco_arena
+
+
+class Square_D0_Agentview_Offcenter(Square_D0):
+    def _load_arena(self):
+        mujoco_arena = super()._load_arena()
+        mujoco_arena.set_camera(
+            camera_name="agentview",
+            pos=string_to_array("1.2 0.2 1.85"),
+            quat=string_to_array("0.6123724 0.3535534 0.3535534 0.6123724"),
+        )
+        return mujoco_arena
+
+
+class Square_D0_Agentview_Offcenter_Mirror(Square_D0):
+    def __init__(self, **kwargs):
+        Square_D0.__init__(self, mirror_scene=True, **kwargs)
+
+    def _load_arena(self):
+        mujoco_arena = super()._load_arena()
+        mujoco_arena.set_camera(
+            camera_name="agentview",
+            pos=string_to_array("1.2 0.2 1.85"),
+            quat=string_to_array("0.6123724 0.3535534 0.3535534 0.6123724"),
+        )
+        return mujoco_arena
+
+    def get_agentview_extrinsics(self):
+        X_C = get_camera_extrinsic_matrix(self.sim, "agentview")
+        X_C[1, 3] = 0
+        return X_C
+
+    def mirror_objects(self):
+        # Override to not mirror the nut
+        for nut_ in self.nuts:
+            res = self.sim.data.get_joint_qpos(nut_.joints[0])
+            pos, quat = res[:3], res[3:]
+            X_C = self.get_agentview_extrinsics()
+            pos, quat = mirror_object(X_C, pos, quat, rot_180=True)
+            res = np.concatenate((pos, quat))
+            self.sim.data.set_joint_qpos(nut_.joints[0], res)
+        self.sim.forward()
+
+
+class Square_D0_Agentview_Far_Mirror(Square_D0_Agentview_Far):
+    def __init__(self, **kwargs):
+        Square_D0_Agentview_Far.__init__(self, mirror_scene=True, **kwargs)
+
+    def mirror_objects(self):
+        # Override to not mirror the nut
+        for nut_ in self.nuts:
+            res = self.sim.data.get_joint_qpos(nut_.joints[0])
+            pos, quat = res[:3], res[3:]
+            X_C = self.get_agentview_extrinsics()
+            pos, quat = mirror_object(X_C, pos, quat, rot_180=True)
+            res = np.concatenate((pos, quat))
+            self.sim.data.set_joint_qpos(nut_.joints[0], res)
+        self.sim.forward()
+        # nut_id = self.sim.model.body_name2id(nut.name)
+        # nut_pos = np.array(self.sim.data.body_xpos[nut_id])
+        # nut_quat = np.array(self.sim.data.body_xquat[nut_id])
+        # print("nut_pos", nut_pos)
+        # print("nut_quat", nut_quat)
+
 
 class Square_D1(Square_D0):
     """
     Specifies a different placement initializer for the pegs where it is initialized
     with a broader x-range and broader y-range.
     """
+
     def _get_initial_placement_bounds(self):
         return dict(
             nut=dict(
                 x=(-0.115, 0.115),
                 y=(-0.255, 0.255),
-                z_rot=(0., 2. * np.pi),
+                z_rot=(0.0, 2.0 * np.pi),
                 # NOTE: hardcoded @self.table_offset since this might be called in init function
                 reference=np.array((0, 0, 0.82)),
             ),
             peg=dict(
                 x=(-0.1, 0.3),
                 y=(-0.2, 0.2),
-                z_rot=(0., 0.),
+                z_rot=(0.0, 0.0),
                 # NOTE: hardcoded @self.table_offset since this might be called in init function
                 reference=np.array((0, 0, 0.82)),
             ),
@@ -155,7 +405,7 @@ class Square_D1(Square_D0):
         if not self.deterministic_reset:
 
             success = False
-            for _ in range(5000): # 5000 retries
+            for _ in range(5000):  # 5000 retries
 
                 # Sample from the placement initializer for all objects
                 object_placements = self.placement_initializer.sample()
@@ -193,8 +443,7 @@ class Square_D1(Square_D0):
                 raise RandomizationError("Cannot place all objects ):")
 
             # Loop through all objects and reset their positions
-            for obj_pos, obj_quat, obj in object_placements.values():
-                self.sim.data.set_joint_qpos(obj.joints[0], np.concatenate([np.array(obj_pos), np.array(obj_quat)]))
+            mirror_object_placements(self.sim, object_placements, self.mirror_scene)
 
         # Move objects out of the scene depending on the mode
         nut_names = {nut.name for nut in self.nuts}
@@ -241,7 +490,7 @@ class Square_D1(Square_D0):
         joints, so we must modify the xml directly before loading the model.
         """
 
-        # skip superclass implementation 
+        # skip superclass implementation
         SingleArmEnv._load_model(self)
 
         # Adjust base pose accordingly
@@ -261,16 +510,20 @@ class Square_D1(Square_D0):
         # Reset sampler before adding any new samplers / objects
         self.placement_initializer.reset()
 
-        for i, (nut_cls, nut_name) in enumerate(zip(
+        for i, (nut_cls, nut_name) in enumerate(
+            zip(
                 (SquareNutObject, RoundNutObject),
                 nut_names,
-        )):
+            )
+        ):
             nut = nut_cls(name=nut_name)
             self.nuts.append(nut)
             # Add this nut to the placement initializer
             if isinstance(self.placement_initializer, SequentialCompositeSampler):
                 # assumes we have two samplers so we add nuts to them
-                self.placement_initializer.add_objects_to_sampler(sampler_name=f"{nut_name}Sampler", mujoco_objects=nut)
+                self.placement_initializer.add_objects_to_sampler(
+                    sampler_name=f"{nut_name}Sampler", mujoco_objects=nut
+                )
             else:
                 # This is assumed to be a flat sampler, so we just add all nuts to this sampler
                 self.placement_initializer.add_objects(nut)
@@ -292,8 +545,26 @@ class Square_D1(Square_D0):
 
         # move peg2 completely out of scene
         peg2_xml_pos = string_to_array(peg1_xml.get("pos"))
-        peg2_xml_pos[0] = -10.
-        peg2_xml_pos[1] = 0.
+        peg2_xml_pos[0] = -10.0
+        peg2_xml_pos[1] = 0.0
+        peg2_xml_quat = None
+
+        cam_pos, cam_quat = mujoco_arena.get_camera("agentview")
+
+        X_C = camera_pose_from_xml(cam_pos, cam_quat)
+
+        if self.mirror_scene:
+            peg1_xml_pos, peg1_xml_quat = mirror_object(
+                X_C,
+                peg1_xml_pos,
+                peg1_xml_quat,
+            )
+
+            peg2_xml_pos, peg2_xml_quat = mirror_object(
+                X_C,
+                peg2_xml_pos,
+                peg2_xml_quat,
+            )
 
         # set modified entry in xml
         peg1_xml.set("pos", array_to_string(peg1_xml_pos))
@@ -309,7 +580,7 @@ class Square_D1(Square_D0):
         # task includes arena, robot, and objects of interest
         self.model = ManipulationTask(
             mujoco_arena=mujoco_arena,
-            mujoco_robots=[robot.robot_model for robot in self.robots], 
+            mujoco_robots=[robot.robot_model for robot in self.robots],
             mujoco_objects=self.nuts,
         )
 
@@ -341,10 +612,78 @@ class Square_D1(Square_D0):
         return observables
 
 
+class Square_D1_Mirror(Square_D1):
+    def __init__(self, **kwargs):
+        Square_D1.__init__(self, mirror_scene=True, **kwargs)
+
+
+class Square_D1_Narrow(Square_D1):
+    """
+    Specifies a different placement initializer for the pegs where it is initialized
+    with a broader x-range and broader y-range.
+    """
+
+    def _load_arena(self):
+        mujoco_arena = super()._load_arena()
+        mujoco_arena.set_camera(
+            camera_name="agentview",
+            pos=string_to_array("0.65 0.0 1.5"),
+            quat=string_to_array("0.653 0.271 0.271 0.653"),
+        )
+        return mujoco_arena
+
+    def _get_initial_placement_bounds(self):
+        return dict(
+            nut=dict(
+                x=(-0.115, -0.11),
+                y=(0.11, 0.225),
+                z_rot=(0.0, 2.0 * np.pi),
+                # NOTE: hardcoded @self.table_offset since this might be called in init function
+                reference=np.array((0, 0, 0.82)),
+            ),
+            peg=dict(
+                x=(0.05, 0.15),
+                y=(-0.05, 0.05),
+                z_rot=(0.0, 0.0),
+                # NOTE: hardcoded @self.table_offset since this might be called in init function
+                reference=np.array((0, 0, 0.82)),
+            ),
+        )
+
+
+class Square_D1_Narrow_Mirror(Square_D1_Narrow):
+    def __init__(self, **kwargs):
+        Square_D1_Narrow.__init__(self, mirror_scene=True, **kwargs)
+
+
+class Square_D1_Narrow_Agentview_Far(Square_D1_Narrow):
+    def _load_arena(self):
+        mujoco_arena = super()._load_arena()
+        mujoco_arena.set_camera(
+            camera_name="agentview",
+            pos=string_to_array("1.2 0.0 1.85"),
+            quat=string_to_array("0.6123724 0.3535534 0.3535534 0.6123724"),
+        )
+        return mujoco_arena
+
+
+class Square_D1_Narrow_Agentview_Far_Mirror(Square_D1_Narrow_Mirror):
+
+    def _load_arena(self):
+        mujoco_arena = super()._load_arena()
+        mujoco_arena.set_camera(
+            camera_name="agentview",
+            pos=string_to_array("1.2 0.0 1.85"),
+            quat=string_to_array("0.6123724 0.3535534 0.3535534 0.6123724"),
+        )
+        return mujoco_arena
+
+
 class Square_D2(Square_D1):
     """
     Even broader range for everything, and z-rotation randomization for peg.
     """
+
     def _load_arena(self):
         """
         Make default camera have full view of tabletop to account for larger init bounds.
@@ -355,10 +694,26 @@ class Square_D2(Square_D1):
         self._add_agentview_full_camera(mujoco_arena)
 
         # Set default agentview camera to be "agentview_full" (and send old agentview camera to agentview_full)
-        old_agentview_camera = find_elements(root=mujoco_arena.worldbody, tags="camera", attribs={"name": "agentview"}, return_first=True)
-        old_agentview_camera_pose = (old_agentview_camera.get("pos"), old_agentview_camera.get("quat"))
-        old_agentview_full_camera = find_elements(root=mujoco_arena.worldbody, tags="camera", attribs={"name": "agentview_full"}, return_first=True)
-        old_agentview_full_camera_pose = (old_agentview_full_camera.get("pos"), old_agentview_full_camera.get("quat"))
+        old_agentview_camera = find_elements(
+            root=mujoco_arena.worldbody,
+            tags="camera",
+            attribs={"name": "agentview"},
+            return_first=True,
+        )
+        old_agentview_camera_pose = (
+            old_agentview_camera.get("pos"),
+            old_agentview_camera.get("quat"),
+        )
+        old_agentview_full_camera = find_elements(
+            root=mujoco_arena.worldbody,
+            tags="camera",
+            attribs={"name": "agentview_full"},
+            return_first=True,
+        )
+        old_agentview_full_camera_pose = (
+            old_agentview_full_camera.get("pos"),
+            old_agentview_full_camera.get("quat"),
+        )
         mujoco_arena.set_camera(
             camera_name="agentview",
             pos=string_to_array(old_agentview_full_camera_pose[0]),
@@ -377,14 +732,14 @@ class Square_D2(Square_D1):
             nut=dict(
                 x=(-0.25, 0.25),
                 y=(-0.25, 0.25),
-                z_rot=(0., 2. * np.pi),
+                z_rot=(0.0, 2.0 * np.pi),
                 # NOTE: hardcoded @self.table_offset since this might be called in init function
                 reference=np.array((0, 0, 0.82)),
             ),
             peg=dict(
                 x=(-0.25, 0.25),
                 y=(-0.25, 0.25),
-                z_rot=(0., np.pi / 2.),
+                z_rot=(0.0, np.pi / 2.0),
                 # NOTE: hardcoded @self.table_offset since this might be called in init function
                 reference=np.array((0, 0, 0.82)),
             ),
diff --git a/mimicgen/envs/robosuite/stack.py b/mimicgen/envs/robosuite/stack.py
index 6009e4f..1ea7cb5 100644
--- a/mimicgen/envs/robosuite/stack.py
+++ b/mimicgen/envs/robosuite/stack.py
@@ -3,27 +3,27 @@
 # Licensed under the NVIDIA Source Code License [see LICENSE for details].
 
 from collections import OrderedDict
-import numpy as np
-
-from robosuite.utils.transform_utils import convert_quat
-from robosuite.utils.mjcf_utils import CustomMaterial, find_elements, string_to_array
 
+import numpy as np
+from mimicgen.envs.robosuite.single_arm_env_mg import SingleArmEnv_MG
 from robosuite.environments.manipulation.single_arm_env import SingleArmEnv
+from robosuite.environments.manipulation.stack import Stack
 from robosuite.models.arenas import TableArena
 from robosuite.models.objects import BoxObject
 from robosuite.models.tasks import ManipulationTask
-from robosuite.utils.placement_samplers import UniformRandomSampler
+from robosuite.utils.mjcf_utils import CustomMaterial, find_elements, string_to_array
 from robosuite.utils.observables import Observable, sensor
-from robosuite.environments.manipulation.stack import Stack
+from robosuite.utils.placement_samplers import UniformRandomSampler
+from robosuite.utils.transform_utils import convert_quat
 
-from mimicgen.envs.robosuite.single_arm_env_mg import SingleArmEnv_MG
+from mirrorduo.utils.core_utils import mirror_object_placements
 
 
 class Stack_D0(Stack, SingleArmEnv_MG):
     """
     Augment robosuite stack task for mimicgen.
     """
-    def __init__(self, **kwargs):
+    def __init__(self, mirror_scene=False, ** kwargs):
         assert "placement_initializer" not in kwargs, "this class defines its own placement initializer"
 
         bounds = self._get_initial_placement_bounds()
@@ -45,6 +45,8 @@ class Stack_D0(Stack, SingleArmEnv_MG):
             z_offset=0.01,
         )
 
+        self.mirror_scene = mirror_scene
+
         Stack.__init__(self, placement_initializer=placement_initializer, **kwargs)
 
     def edit_model_xml(self, xml_str):
@@ -188,6 +190,20 @@ class Stack_D0(Stack, SingleArmEnv_MG):
             for k in ["cubeA", "cubeB"]
         }
 
+    # [mirrorduo]: added for mirroring the scene at every reset
+    def _reset_internal(self):
+        """
+        Resets simulation internal configurations.
+        """
+        super()._reset_internal()
+        # Reset all object positions using initializer sampler if we're not directly loading from an xml
+        if not self.deterministic_reset:
+            # Sample from the placement initializer for all objects
+            object_placements = self.placement_initializer.sample()
+            # Loop through all objects and reset their positions
+            mirror_object_placements(
+                self.sim, object_placements, self.mirror_scene)
+
 
 class Stack_D1(Stack_D0):
     """
@@ -235,7 +251,7 @@ class StackThree(Stack_D0):
     """
     Stack three cubes instead of two.
     """
-    def __init__(self, **kwargs):
+    def __init__(self, mirror_scene=False, **kwargs):
         assert "placement_initializer" not in kwargs, "this class defines its own placement initializer"
 
         bounds = self._get_initial_placement_bounds()
@@ -258,6 +274,7 @@ class StackThree(Stack_D0):
             z_offset=0.01,
         )
 
+        self.mirror_scene = mirror_scene
         Stack.__init__(self, placement_initializer=placement_initializer, **kwargs)
 
     def reward(self, action=None):
@@ -509,6 +526,7 @@ class StackThree_D1(StackThree_D0):
     """
     Less z-rotation (for easier datagen) and much wider initialization bounds.
     """
+
     def _load_arena(self):
         """
         Make default camera have full view of tabletop to account for larger init bounds.
@@ -545,3 +563,22 @@ class StackThree_D1(StackThree_D0):
             )
             for k in ["cubeA", "cubeB", "cubeC"]
         }
+
+
+class StackThree_D0_Mirror(StackThree_D0):
+    def __init__(self, **kwargs):
+        """
+        Initialize the Coffee_D0_Mirror environment.
+        """
+        StackThree_D0.__init__(self, mirror_scene=True, **kwargs)
+
+
+class StackThree_D1_Agentview_Offcenter(StackThree_D1):
+    def _load_arena(self):
+        mujoco_arena = super()._load_arena()
+        mujoco_arena.set_camera(
+            camera_name="agentview",
+            pos=string_to_array("1.2 0.2 1.85"),
+            quat=string_to_array("0.6123724 0.3535534 0.3535534 0.6123724"),
+        )
+        return mujoco_arena
